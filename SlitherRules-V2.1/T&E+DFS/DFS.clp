
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;                              CSP-RULES / SLITHERRULES
;;;                              DEPTH-FIRST SEARCH (DFS)
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               ;;;                                                    ;;;
               ;;;              copyright Denis Berthier              ;;;
               ;;;     https://denis-berthier.pagesperso-orange.fr    ;;;
               ;;;            January 2006 - August 2020              ;;;
               ;;;                                                    ;;;
               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



; -*- clips -*-





(defrule DFS-detect-solution-in-context
    (declare (salience ?*solution-found-salience*))
    ?pl0 <- (play)
    ?brt0 <- (technique 0 BRT)
    (context (name ?cont))
    ?brt <- (technique ?cont BRT)
    ;;; in any context ?cont, the presence of a c-value for all the csp-variables (of some type) means that a solution has been found in ?cont
    (forall (csp-variable (name ?csp)) ; (type ?type&:(is-basic-csp-variable-type ?type))
        (exists (is-csp-variable-for-label (csp-var ?csp) (label ?lab))
            (candidate (context ?cont) (status c-value) (label ?lab))
        )
    )
=>
    (printout t "PUZZLE IS SOLVED.")
    (printout t " rating-type = " ?*rating-type* ", MAX-DEPTH = " ?*DFS-max-depth* crlf)
    (retract ?pl0)
    (retract ?brt0)
    (retract ?brt)
    (assert (solution-found ?cont))
)




(defrule DFS-generate-context
	(declare (salience ?*DFS-generate-context-salience*))
	(context (name ?par) (depth ?depth))
    (technique ?par DFS)
    ;;; only one direct descendant of ?par is considered at a time:
    ;(not (context (name ?cont&~?par) (parent ?par) (depth ?depth1&:(eq ?depth1 (+ 1 ?depth)))))
    ?gen <- (candidate (context ?par) (status cand) (label ?gen-cand) (type H|V))
=>
	;;; choose ?gen-cand as a hypothesis	
	(bind ?*context-counter* (+ ?*context-counter* 1))
    (bind ?depth1 (+ ?depth 1))
    (bind ?*DFS-max-depth* (max ?*DFS-max-depth* ?depth1))
	(if (or ?*print-actions* ?*print-hypothesis*) then
		(printout t "GENERATING CONTEXT " ?*context-counter* " AT DEPTH " ?depth1 ", SON OF CONTEXT " ?par ", FROM HYPOTHESIS " (print-label ?gen-cand) "." crlf)
        (printout t "DFS-max-depth = " ?*DFS-max-depth* crlf)
	)
	;;; assert the new context
	(assert (context (name ?*context-counter*) (parent ?par) (depth ?depth1) (generating-cand ?gen-cand)))
	(assert (technique ?*context-counter* BRT))
	;;; assert the generating value of the new context, with flag 0
	(duplicate ?gen (context ?*context-counter*) (status c-value) (flag 0))
)



;;; complete contradiction detection in context

(defrule DFS-detect-contradiction-in-non-first-context
    (declare (salience ?*contradiction-in-context-salience*))
    ;;; if, in a context generated by ?gen-cand, which is not the first
    (technique ?cont DFS)
    (context (name ?cont&~0) (parent ?par&0) (generating-cand ?gen-cand))
    ?g <- (candidate (context ?par) (status cand) (label ?gen-cand) (type ?type&H|V) (row ?row) (column ?col) (value ?val))
    ;;; if there is a csp-variable with no c-value and no candidate in ?cont
    (csp-variable (name ?csp))
    (forall (is-csp-variable-for-label (csp-var ?csp) (label ?lab))
        (not (candidate (context ?cont) (label ?lab)))
    )
    (phase ?par ?ph)
    (not (clean-and-retract ?cont))
    ?g-opp <- (candidate (context ?par) (status cand) (label ?gen-cand-opp) (type ?type) (row ?row) (column ?col) (value ?val-opp&~?val))
=>
    ;;; then eliminate the generating candidate from the parent context
    (retract ?g)
    (modify ?g-opp (status c-value))
    (if (eq ?par 0) then (bind ?*nb-candidates* (- ?*nb-candidates* 1)))
    (if (or ?*print-actions* ?*print-hypothesis*) then
        (printout t "NO POSSIBLE VALUE for csp-variable " ?csp " IN CONTEXT " ?cont ".")
        (printout t " RETRACTING CANDIDATE " (print-label ?gen-cand) " FROM CONTEXT " ?par "." crlf crlf)
        (printout t " ASSERTING CANDIDATE " (print-label ?gen-cand-opp) " FOR CONTEXT " ?par "." crlf crlf)
    )
    ;;; remember that this phase was productive
    (assert (phase-productive-in-context ?par ?ph))
    ;;; properly destroy the present context so as not to saturate memory
    (assert (clean-and-retract ?cont))
)











