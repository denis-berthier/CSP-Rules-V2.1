/***********************************************************************
*                                                                      *
*                       Copyright (c) 2005-2006                        *
*                         All Rights Reserved                          *
*                                 gsf                                  *
*                                                                      *
***********************************************************************/
/*
 * Glenn Fowler
 * AT&T Research
 * 9x9 sudoku canonicalization
 */

typedef struct Canon_s
{
	unsigned char	box;
	unsigned char	map[10];
	unsigned char	row[9];
	unsigned char	col[9];
} Canon_t;

static const unsigned char	swap[18][9][9] =
{
	{
		{  0, 1, 2, 3, 4, 5, 6, 7, 8 },
		{  9,10,11,12,13,14,15,16,17 },
		{ 18,19,20,21,22,23,24,25,26 },
		{ 27,28,29,30,31,32,33,34,35 },
		{ 36,37,38,39,40,41,42,43,44 },
		{ 45,46,47,48,49,50,51,52,53 },
		{ 54,55,56,57,58,59,60,61,62 },
		{ 63,64,65,66,67,68,69,70,71 },
		{ 72,73,74,75,76,77,78,79,80 },
	},
	{
		{  3, 4, 5, 6, 7, 8, 0, 1, 2 },
		{ 12,13,14,15,16,17, 9,10,11 },
		{ 21,22,23,24,25,26,18,19,20 },
		{ 30,31,32,33,34,35,27,28,29 },
		{ 39,40,41,42,43,44,36,37,38 },
		{ 48,49,50,51,52,53,45,46,47 },
		{ 57,58,59,60,61,62,54,55,56 },
		{ 66,67,68,69,70,71,63,64,65 },
		{ 75,76,77,78,79,80,72,73,74 },
	},
	{
		{  6, 7, 8, 0, 1, 2, 3, 4, 5 },
		{ 15,16,17, 9,10,11,12,13,14 },
		{ 24,25,26,18,19,20,21,22,23 },
		{ 33,34,35,27,28,29,30,31,32 },
		{ 42,43,44,36,37,38,39,40,41 },
		{ 51,52,53,45,46,47,48,49,50 },
		{ 60,61,62,54,55,56,57,58,59 },
		{ 69,70,71,63,64,65,66,67,68 },
		{ 78,79,80,72,73,74,75,76,77 },
	},
	{
		{ 27,28,29,30,31,32,33,34,35 },
		{ 36,37,38,39,40,41,42,43,44 },
		{ 45,46,47,48,49,50,51,52,53 },
		{ 54,55,56,57,58,59,60,61,62 },
		{ 63,64,65,66,67,68,69,70,71 },
		{ 72,73,74,75,76,77,78,79,80 },
		{  0, 1, 2, 3, 4, 5, 6, 7, 8 },
		{  9,10,11,12,13,14,15,16,17 },
		{ 18,19,20,21,22,23,24,25,26 },
	},
	{
		{ 30,31,32,33,34,35,27,28,29 },
		{ 39,40,41,42,43,44,36,37,38 },
		{ 48,49,50,51,52,53,45,46,47 },
		{ 57,58,59,60,61,62,54,55,56 },
		{ 66,67,68,69,70,71,63,64,65 },
		{ 75,76,77,78,79,80,72,73,74 },
		{  3, 4, 5, 6, 7, 8, 0, 1, 2 },
		{ 12,13,14,15,16,17, 9,10,11 },
		{ 21,22,23,24,25,26,18,19,20 },
	},
	{
		{ 33,34,35,27,28,29,30,31,32 },
		{ 42,43,44,36,37,38,39,40,41 },
		{ 51,52,53,45,46,47,48,49,50 },
		{ 60,61,62,54,55,56,57,58,59 },
		{ 69,70,71,63,64,65,66,67,68 },
		{ 78,79,80,72,73,74,75,76,77 },
		{  6, 7, 8, 0, 1, 2, 3, 4, 5 },
		{ 15,16,17, 9,10,11,12,13,14 },
		{ 24,25,26,18,19,20,21,22,23 },
	},
	{
		{ 54,55,56,57,58,59,60,61,62 },
		{ 63,64,65,66,67,68,69,70,71 },
		{ 72,73,74,75,76,77,78,79,80 },
		{  0, 1, 2, 3, 4, 5, 6, 7, 8 },
		{  9,10,11,12,13,14,15,16,17 },
		{ 18,19,20,21,22,23,24,25,26 },
		{ 27,28,29,30,31,32,33,34,35 },
		{ 36,37,38,39,40,41,42,43,44 },
		{ 45,46,47,48,49,50,51,52,53 },
	},
	{
		{ 57,58,59,60,61,62,54,55,56 },
		{ 66,67,68,69,70,71,63,64,65 },
		{ 75,76,77,78,79,80,72,73,74 },
		{  3, 4, 5, 6, 7, 8, 0, 1, 2 },
		{ 12,13,14,15,16,17, 9,10,11 },
		{ 21,22,23,24,25,26,18,19,20 },
		{ 30,31,32,33,34,35,27,28,29 },
		{ 39,40,41,42,43,44,36,37,38 },
		{ 48,49,50,51,52,53,45,46,47 },
	},
	{
		{ 60,61,62,54,55,56,57,58,59 },
		{ 69,70,71,63,64,65,66,67,68 },
		{ 78,79,80,72,73,74,75,76,77 },
		{  6, 7, 8, 0, 1, 2, 3, 4, 5 },
		{ 15,16,17, 9,10,11,12,13,14 },
		{ 24,25,26,18,19,20,21,22,23 },
		{ 33,34,35,27,28,29,30,31,32 },
		{ 42,43,44,36,37,38,39,40,41 },
		{ 51,52,53,45,46,47,48,49,50 },
	},
	{
		{  0, 9,18,27,36,45,54,63,72 },
		{  1,10,19,28,37,46,55,64,73 },
		{  2,11,20,29,38,47,56,65,74 },
		{  3,12,21,30,39,48,57,66,75 },
		{  4,13,22,31,40,49,58,67,76 },
		{  5,14,23,32,41,50,59,68,77 },
		{  6,15,24,33,42,51,60,69,78 },
		{  7,16,25,34,43,52,61,70,79 },
		{  8,17,26,35,44,53,62,71,80 },
	},
	{
		{  3,12,21,30,39,48,57,66,75 },
		{  4,13,22,31,40,49,58,67,76 },
		{  5,14,23,32,41,50,59,68,77 },
		{  6,15,24,33,42,51,60,69,78 },
		{  7,16,25,34,43,52,61,70,79 },
		{  8,17,26,35,44,53,62,71,80 },
		{  0, 9,18,27,36,45,54,63,72 },
		{  1,10,19,28,37,46,55,64,73 },
		{  2,11,20,29,38,47,56,65,74 },
	},
	{
		{  6,15,24,33,42,51,60,69,78 },
		{  7,16,25,34,43,52,61,70,79 },
		{  8,17,26,35,44,53,62,71,80 },
		{  0, 9,18,27,36,45,54,63,72 },
		{  1,10,19,28,37,46,55,64,73 },
		{  2,11,20,29,38,47,56,65,74 },
		{  3,12,21,30,39,48,57,66,75 },
		{  4,13,22,31,40,49,58,67,76 },
		{  5,14,23,32,41,50,59,68,77 },
	},
	{
		{ 27,36,45,54,63,72, 0, 9,18 },
		{ 28,37,46,55,64,73, 1,10,19 },
		{ 29,38,47,56,65,74, 2,11,20 },
		{ 30,39,48,57,66,75, 3,12,21 },
		{ 31,40,49,58,67,76, 4,13,22 },
		{ 32,41,50,59,68,77, 5,14,23 },
		{ 33,42,51,60,69,78, 6,15,24 },
		{ 34,43,52,61,70,79, 7,16,25 },
		{ 35,44,53,62,71,80, 8,17,26 },
	},
	{
		{ 30,39,48,57,66,75, 3,12,21 },
		{ 31,40,49,58,67,76, 4,13,22 },
		{ 32,41,50,59,68,77, 5,14,23 },
		{ 33,42,51,60,69,78, 6,15,24 },
		{ 34,43,52,61,70,79, 7,16,25 },
		{ 35,44,53,62,71,80, 8,17,26 },
		{ 27,36,45,54,63,72, 0, 9,18 },
		{ 28,37,46,55,64,73, 1,10,19 },
		{ 29,38,47,56,65,74, 2,11,20 },
	},
	{
		{ 33,42,51,60,69,78, 6,15,24 },
		{ 34,43,52,61,70,79, 7,16,25 },
		{ 35,44,53,62,71,80, 8,17,26 },
		{ 27,36,45,54,63,72, 0, 9,18 },
		{ 28,37,46,55,64,73, 1,10,19 },
		{ 29,38,47,56,65,74, 2,11,20 },
		{ 30,39,48,57,66,75, 3,12,21 },
		{ 31,40,49,58,67,76, 4,13,22 },
		{ 32,41,50,59,68,77, 5,14,23 },
	},
	{
		{ 54,63,72, 0, 9,18,27,36,45 },
		{ 55,64,73, 1,10,19,28,37,46 },
		{ 56,65,74, 2,11,20,29,38,47 },
		{ 57,66,75, 3,12,21,30,39,48 },
		{ 58,67,76, 4,13,22,31,40,49 },
		{ 59,68,77, 5,14,23,32,41,50 },
		{ 60,69,78, 6,15,24,33,42,51 },
		{ 61,70,79, 7,16,25,34,43,52 },
		{ 62,71,80, 8,17,26,35,44,53 },
	},
	{
		{ 57,66,75, 3,12,21,30,39,48 },
		{ 58,67,76, 4,13,22,31,40,49 },
		{ 59,68,77, 5,14,23,32,41,50 },
		{ 60,69,78, 6,15,24,33,42,51 },
		{ 61,70,79, 7,16,25,34,43,52 },
		{ 62,71,80, 8,17,26,35,44,53 },
		{ 54,63,72, 0, 9,18,27,36,45 },
		{ 55,64,73, 1,10,19,28,37,46 },
		{ 56,65,74, 2,11,20,29,38,47 },
	},
	{
		{ 60,69,78, 6,15,24,33,42,51 },
		{ 61,70,79, 7,16,25,34,43,52 },
		{ 62,71,80, 8,17,26,35,44,53 },
		{ 54,63,72, 0, 9,18,27,36,45 },
		{ 55,64,73, 1,10,19,28,37,46 },
		{ 56,65,74, 2,11,20,29,38,47 },
		{ 57,66,75, 3,12,21,30,39,48 },
		{ 58,67,76, 4,13,22,31,40,49 },
		{ 59,68,77, 5,14,23,32,41,50 },
	},
};

static const unsigned char	perm[6][3] =
{
	{ 1, 0, 2 },
	{ 0, 1, 2 },
	{ 0, 2, 1 },
	{ 2, 0, 1 },
	{ 2, 1, 0 },
	{ 1, 2, 0 }
};

static const unsigned char	part[9][5] =
{
	{ 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0 },
	{ 4, 5, 6, 7, 8 },
	{ 3, 5, 6, 7, 8 },
	{ 3, 4, 6, 7, 8 },
	{ 7, 8, 3, 4, 5 },
	{ 6, 8, 3, 4, 5 },
	{ 6, 7, 3, 4, 5 },
};

/*
 * canonicalize solution grid sol[0..80] into can[0..80]
 *
 * sol is a one dimensional array of the grid in row order
 * with 1..9 for cell values
 *
 * canonical solution is the smallest lexicographic sequence
 * can[0]..can[80] with (the top left box fixed to)
 *	 can[0]=1   can[1]=2   can[2]=3
 *	 can[9]=4  can[10]=5  can[11]=6
 *	can[18]=7  can[19]=8  can[20]=9
 */

void
canon(unsigned char* sol, unsigned char* can)
{
	register int	b;
	register int	d;
	register int	i;
	register int	j;
	register int	k;
	register int	l;
	register int	v;

	int		pr;
	int		pc;

	Canon_t		test;
	Canon_t		best;

	/* this shuts up -Wall */

	l = 0;

	/* initialize the worst canonical candidate */

	best.box = 0;
	for (i = 0; i < 9; i++)
	{
		best.map[i] = 10;
		best.row[i] = best.col[i] = i;
	}
	best.map[i] = 10;

	/* search over all boxes */

	for (b = 0; b < 18; b++)
		for (pr = 0; pr < 6; pr++)
			for (pc = 0; pc < 6; pc++)
			{
				test.box = b;

				/* initialize the map */

				for (i = 0; i < 3; i++)
				{
					test.row[i] = perm[pr][i];
					test.col[i] = perm[pc][i];
				}
				k = 0;
				for (i = 0; i < 3; i++)
					for (j = 0; j < 3; j++)
						test.map[sol[swap[b][test.row[i]][test.col[j]]]] = ++k;

				/* order the non-box columns */

				v = 10;
				for (j = 3; j < 9; j++)
					if (test.map[sol[swap[b][test.row[0]][j]]] < v)
					{
						v = test.map[sol[swap[b][test.row[0]][j]]];
						k = j;
					}

				/* check col 3 */

				if ((d = (int)test.map[sol[swap[test.box][test.row[0]][k]]] - (int)best.map[sol[swap[best.box][best.row[0]][best.col[3]]]]) > 0)
					goto next;
				test.col[3] = k;
				if (test.map[sol[swap[b][test.row[0]][part[k][0]]]] < test.map[sol[swap[b][test.row[0]][part[k][1]]]])
				{
					test.col[4] = part[k][0];
					test.col[5] = part[k][1];
				}
				else
				{
					test.col[4] = part[k][1];
					test.col[5] = part[k][0];
				}

				/* check cols 4&5 */

				if (!d)
					for (j = 4; j < 6; j++)
						if ((d = (int)test.map[sol[swap[test.box][test.row[0]][test.col[j]]]] - (int)best.map[sol[swap[best.box][best.row[0]][best.col[j]]]]))
						{
							if (d > 0)
								goto next;
							break;
						}
				v = 10;
				for (j = 2; j < 5; j++)
					if (test.map[sol[swap[b][test.row[0]][part[k][j]]]] < v)
					{
						v = test.map[sol[swap[b][test.row[0]][part[k][j]]]];
						l = part[k][j];
					}

				/* check col 6 */

				if (!d && (d = (int)test.map[sol[swap[test.box][test.row[0]][k]]] - (int)best.map[sol[swap[best.box][best.row[0]][best.col[3]]]]) > 0)
					goto next;
				test.col[6] = l;
				if (test.map[sol[swap[b][test.row[0]][part[l][0]]]] < test.map[sol[swap[b][test.row[0]][part[l][1]]]])
				{
					test.col[7] = part[l][0];
					test.col[8] = part[l][1];
				}
				else
				{
					test.col[7] = part[l][1];
					test.col[8] = part[l][0];
				}

				/* check cols 7&8 */

				if (!d)
					for (j = 7; j < 9; j++)
						if ((d = (int)test.map[sol[swap[test.box][test.row[0]][test.col[j]]]] - (int)best.map[sol[swap[best.box][best.row[0]][best.col[j]]]]))
						{
							if (d > 0)
								goto next;
							break;
						}

				/* check the remainder of the top band sans the top left box */

				if (!d)
					for (i = 1; i < 3; i++)
						for (j = 3; j < 9; j++)
							if ((d = (int)test.map[sol[swap[test.box][test.row[i]][test.col[j]]]] - (int)best.map[sol[swap[best.box][best.row[i]][best.col[j]]]]))
							{
								if (d > 0)
									goto next;
								i = 3;
								break;
							}

				/* order the non-box rows */

				v = 10;
				for (i = 3; i < 9; i++)
					if (test.map[sol[swap[b][i][test.col[0]]]] < v)
					{
						v = test.map[sol[swap[b][i][test.col[0]]]];
						k = i;
					}

				/* check row 3 */

				if (!d)
					for (j = 0; j < 9; j++)
						if ((d = (int)test.map[sol[swap[test.box][k][test.col[j]]]] - (int)best.map[sol[swap[best.box][best.row[3]][best.col[j]]]]))
						{
							if (d > 0)
								goto next;
							break;
						}
				test.row[3] = k;
				if (test.map[sol[swap[b][part[k][0]][test.col[0]]]] < test.map[sol[swap[b][part[k][1]][test.col[0]]]])
				{
					test.row[4] = part[k][0];
					test.row[5] = part[k][1];
				}
				else
				{
					test.row[4] = part[k][1];
					test.row[5] = part[k][0];
				}

				/* check rows 4&5 */

				if (!d)
					for (i = 4; i < 6; i++)
						for (j = 0; j < 9; j++)
							if ((d = (int)test.map[sol[swap[test.box][test.row[i]][test.col[j]]]] - (int)best.map[sol[swap[best.box][best.row[i]][best.col[j]]]]))
							{
								if (d > 0)
									goto next;
								i = 6;
								break;
							}
				v = 10;
				for (i = 2; i < 5; i++)
					if (test.map[sol[swap[b][part[k][i]][test.col[0]]]] < v)
					{
						v = test.map[sol[swap[b][part[k][i]][test.col[0]]]];
						l = part[k][i];
					}

				/* check row 6 */

				if (!d)
					for (j = 0; j < 9; j++)
						if ((d = (int)test.map[sol[swap[test.box][l][test.col[j]]]] - (int)best.map[sol[swap[best.box][best.row[6]][best.col[j]]]]))
						{
							if (d > 0)
								goto next;
							break;
						}
				test.row[6] = l;
				if (test.map[sol[swap[b][part[l][0]][test.col[0]]]] < test.map[sol[swap[b][part[l][1]][test.col[0]]]])
				{
					test.row[7] = part[l][0];
					test.row[8] = part[l][1];
				}
				else
				{
					test.row[7] = part[l][1];
					test.row[8] = part[l][0];
				}

				/* check the remaining rows */

				if (!d)
					for (i = 7; i < 9; i++)
						for (j = 0; j < 9; j++)
							if ((d = (int)test.map[sol[swap[test.box][test.row[i]][test.col[j]]]] - (int)best.map[sol[swap[best.box][best.row[i]][best.col[j]]]]))
							{
								if (d > 0)
									goto next;
								i = 9;
								break;
							}
				best = test;
			next:;
			}
	for (i = 0; i < 9; i++)
		for (j = 0; j < 9; j++)
			*can++ = best.map[sol[swap[best.box][best.row[i]][best.col[j]]]];
}
